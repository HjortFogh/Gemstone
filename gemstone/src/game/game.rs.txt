use rand::{seq::SliceRandom, thread_rng};

pub fn score_game(inventories: &[PlayerInventory]) -> Vec<i32> {
    let mut scores = vec![0; inventories.len()];
    // one point for each non-leveraged gem
    for (i, inv) in inventories.iter().enumerate() {
        let sum: i32 = inv
            .iter()
            .non_leveraged()
            .gem_cards()
            .map(|gem_card| gem_card.num_gems())
            .sum();
        scores[i] += sum;
    }
    // two points for each shared majority
    // three points for each owned majority
    for gem_type in GemType::all_types() {
        let mut highest_n = 0;
        let mut winners = Vec::new();
        for (i, inv) in inventories.iter().enumerate() {
            let n: i32 = inv
                .iter()
                .non_leveraged()
                .gem_cards()
                .map(|gem_card| gem_card.num_gems_with_type(gem_type))
                .sum();
            if n > highest_n {
                highest_n = n;
                winners.clear();
                winners.push(i);
            } else if n == highest_n {
                winners.push(i);
            }
        }
        if highest_n > 0 {
            let num_points = i32::from(winners.len() == 1) + 2;
            for i in winners {
                scores[i] += num_points;
            }
        }
    }
    scores
}

pub struct Game {
    /// Inventories of all the players.
    pub(crate) inventories: Vec<PlayerInventory>,
    /// Behaviors of all the players.
    pub(crate) behaviors: Vec<Box<dyn PlayerBehavior>>,
    /// The current mutatable vector of cards.
    /// This is always an empty vector if in the reinvestment phase.
    pub(crate) current_stack: Vec<GemCard>,
    /// Unmutable copy of all the stacks.
    pub(crate) all_stacks: [Vec<GemCard>; 6],
    /// Boolean indicating whether this game has ended.
    pub(crate) game_over: bool,
    /// The current round index in range `[0..6)`.
    pub(crate) round_idx: usize,
    /// The current player index in range `[0..num_players)`.
    pub(crate) current_player_idx: usize,
    /// The index of the current highest bidder in the auction phase.
    pub(crate) highest_bidder_idx: usize,
    /// The index of the starting bidder in the auction phase.
    pub(crate) starting_bidder_idx: usize,
    /// The highest bid made by any player, or `-1` if no bids have been made.
    pub(crate) highest_bid: i8,
}

impl Game {
    //
    // Public interface
    //

    pub fn new(mut behaviors: Vec<Box<dyn PlayerBehavior>>) -> Result<Self> {
        // check if a correct amount of players exist
        // the caller guarantees that at most four players exist
        if behaviors.len() < 2 {
            return Err(GemError::ToFewPlayers);
        }
        // make a random player start
        let mut rng = thread_rng();
        behaviors.shuffle(&mut rng);

        // create the player inventories
        let inventories: Vec<PlayerInventory> = (0..behaviors.len())
            .map(|_| PlayerInventory::default())
            .collect();

        // create the deck and shuffle
        let mut deck = DEFAULT_GEM_DECK.to_vec();
        deck.shuffle(&mut rng);
        let mut all_stacks = Self::calculate_stacks(deck, behaviors.len());

        // by default all cards are leveraged, except for the last round
        for i in 0..5 {
            all_stacks[i]
                .iter_mut()
                .for_each(|gem_card| gem_card.leverage());
        }

        Ok(Self {
            inventories: inventories.clone(),
            behaviors,
            current_stack: all_stacks[0].clone(),
            all_stacks,
            game_over: false,
            round_idx: 0,
            current_player_idx: 0,
            highest_bidder_idx: 0,
            starting_bidder_idx: 0,
            highest_bid: -1,
        })
    }

    #[inline]
    pub fn game_over(&self) -> bool {
        self.game_over
    }

    pub fn run(&mut self) -> Result<()> {
        while !self.game_over {
            self.step()?;
        }
        Ok(())
    }

    pub fn step(&mut self) -> Result<()> {
        if self.game_over {
            return Err(GemError::GameAlreadyOver);
        } else if self.is_auction_phase() {
            self.step_auction_phase()?;
        } else {
            self.step_reinvestment_phase()?;
        }
        Ok(())
    }

    //
    // Auction phase
    //

    fn step_auction_phase(&mut self) -> Result<()> {
        // get a bid from the current player
        // if the player is the first to bet it is possible to win with a bet of zero
        let query = GameQuery::from_game(&self, self.current_player_idx);
        let mut bid = self.current_player().bid(query);
        bid = bid.max(0);
        // check if the player can bid this amount
        if !self.inventories[self.current_player_idx].can_bid(bid) {
            return Err(GemError::CannotAffordBet);
        }
        // if the bid is higher than the current highest bid, set this as the highest bid
        if bid > self.highest_bid {
            self.highest_bid = bid;
            self.highest_bidder_idx = self.current_player_idx;
        }

        self.set_next_player();
        // if the current player is equal to the beginning player
        if self.starting_bidder_idx == self.current_player_idx {
            // get players choice of card and which cards to pay leverage
            let query = GameQuery::from_game(&self, self.highest_bidder_idx);
            let (mut card_choise_idx, payment_cards_idx) =
                self.behaviors[self.highest_bidder_idx].pick_card(query);
            card_choise_idx = card_choise_idx.clamp(0, self.current_stack.len() - 1);

            // check if any of the leveraged cards have already been leveraged
            if self.inventories[self.highest_bidder_idx]
                .iter_cards(&payment_cards_idx)
                .non_leveraged()
                .count()
                != payment_cards_idx.len()
            {
                return Err(GemError::TriedToUseLeveragedCard);
            }

            // check if the sum of all the leveraged cards equal or exceed the bid
            let invested_sum = self.inventories[self.highest_bidder_idx]
                .iter_cards(&payment_cards_idx)
                .filter_map(|gem_card| gem_card.get_value())
                .sum::<i8>();
            if invested_sum < self.highest_bid {
                return Err(GemError::ToFewGemCards);
            }

            // leverage all the cards used to pay for the bid
            self.inventories[self.highest_bidder_idx]
                .iter_mut_cards(&payment_cards_idx)
                .for_each(|gem_card| gem_card.leverage());

            // move the card from the stack to the players hand
            let card = self.current_stack.remove(card_choise_idx);
            self.inventories[self.highest_bidder_idx].push(card);

            // set next starting better
            self.starting_bidder_idx = self.next_clockwise_player(self.highest_bidder_idx);
            self.current_player_idx = self.starting_bidder_idx;
            self.highest_bid = -1;
        }
        // if there are no more cards to be bought
        if !self.is_auction_phase() {
            // the player who won the last card shall start in the reinvestment phase
            self.current_player_idx = self.highest_bidder_idx;
        }
        Ok(())
    }

    //
    // Reinvestment phase
    //

    fn step_reinvestment_phase(&mut self) -> Result<()> {
        // query player for their reinvestment choices
        let query = GameQuery::from_game(&self, self.current_player_idx);
        let (payment_cards_idx, leveraged_cards_idx) = self.current_player().reinvest(query);

        // check if the player tries to pay with leveraged card
        if self.inventories[self.current_player_idx]
            .iter_cards(&payment_cards_idx)
            .leveraged()
            .count()
            != 0
        {
            return Err(GemError::TriedToUseLeveragedCard);
        }
        // check if player tries to flip already-flipped card
        if self.inventories[self.current_player_idx]
            .iter_cards(&leveraged_cards_idx)
            .non_leveraged()
            .count()
            != 0
        {
            return Err(GemError::TriedToFlipNonLeveragedCard);
        }
        // check if player tries to flip coin card
        if self.inventories[self.current_player_idx]
            .iter_cards(&leveraged_cards_idx)
            .filter(|gem_card| gem_card.is_coin())
            .count()
            != 0
        {
            return Err(GemError::TriedToFlipCoinCard);
        }
        // calculate the payment and leveraged values
        let payment: i8 = self.inventories[self.current_player_idx]
            .iter_cards(&payment_cards_idx)
            .map(|gem_card| gem_card.value())
            .sum();
        let leveraged_value: i8 = self.inventories[self.current_player_idx]
            .iter_cards(&leveraged_cards_idx)
            .map(|gem_card| gem_card.flip_value())
            .sum();
        if payment < leveraged_value {
            return Err(GemError::CannotAffortToFlip);
        }
        // flip the payment and leveraged cards
        self.inventories[self.current_player_idx]
            .iter_mut_cards(&payment_cards_idx)
            .for_each(|gem_card| gem_card.leverage());
        self.inventories[self.current_player_idx]
            .iter_mut_cards(&leveraged_cards_idx)
            .for_each(|gem_card| gem_card.flip());

        self.set_next_player();
        // if all players have reinvested
        if self.current_player_idx == self.highest_bidder_idx {
            if self.round_idx >= 5 {
                let scores = score_game(&self.inventories);
                println!("final scores: {scores:?}");
                self.game_over = true;
            } else {
                // set the next stack
                self.round_idx += 1;
                self.current_stack = self.all_stacks[self.round_idx].clone();
                // set the starting bidder to the player after the last winner
                self.starting_bidder_idx = self.next_clockwise_player(self.highest_bidder_idx);
                self.current_player_idx = self.starting_bidder_idx;
                // flip all players coin cards
                for inventory in &mut self.inventories {
                    inventory.flip_coins();
                }
            }
        }
        Ok(())
    }

    //
    // Helper functions
    //

    pub fn query(&self) -> GameQuery {
        GameQuery::from_game(self, self.current_player_idx)
    }

    fn calculate_stacks(deck: Vec<GemCard>, n: usize) -> [Vec<GemCard>; 6] {
        // if two or four players, make the first and last stack have respectivly four and two cards
        // otherwise make all stacks have three cards
        let sizes = if n % 2 == 0 {
            [4, 3, 3, 3, 3, 2]
        } else {
            [3, 3, 3, 3, 3, 3]
        };

        let mut stacks: [Vec<GemCard>; 6] = Default::default();
        let mut start = 0;

        for (i, &size) in sizes.iter().enumerate() {
            stacks[i] = deck[start..start + size].to_vec();
            start += size;
        }

        stacks
    }

    #[inline]
    fn is_auction_phase(&self) -> bool {
        !self.current_stack.is_empty()
    }

    #[inline]
    fn current_player(&mut self) -> &mut dyn PlayerBehavior {
        &mut *self.behaviors[self.current_player_idx]
    }

    #[inline]
    fn next_clockwise_player(&self, n: usize) -> usize {
        (n + 1) % self.behaviors.len()
    }

    #[inline]
    fn set_next_player(&mut self) {
        self.current_player_idx = self.next_clockwise_player(self.current_player_idx);
    }
}
